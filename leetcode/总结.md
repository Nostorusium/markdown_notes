# Summary

## 双指针

### 相对指针

*e.g.* 两数之和，三数之和

相对指针的一个通用思想是:
对于有序nums，若：
```
nums[left]+nums[right]>target
```
说明右侧较大数过大。若：
```
nums[left]+nums[right]<tatget
```
说明左侧较小数过小。

通常而言两个指针向内逼近。对于三数之和，可以通过先枚举一个数将此问题退化为两数之和。

## 滑动窗口

### 不定长滑动窗口

维护一个有条件的滑动窗口
1. 右端点右移，导致窗口扩大，是不满足条件的罪魁祸首
2. 左端点右移目的是为了缩小窗口，重新满足条件

```
# 209. 长度最小的子数组
for right in range(len(nums)):
   # 右移右边界
   curSum += nums[right]
   # 尝试尽可能缩短长度
   while curSum >= target:
       minLength = min(minLength,right-left+1)
       curSum -= nums[left]
       left += 1
return minLength if minLength<114514 else 0
```

滑动窗口的特点在于，在给定顺序结构中遍历所有可行的子结构。

### 定长滑动窗口

1. 入右端点
2. 更新
3. 出左端点

```
for right in range(len(nums)):
   # 入
   curSum += nums[right]
   left = right-k+1
   if left<0 : continue

   # 更新
   res = max(res,curSum)

   # 出
   curSum -= nums[left]
```

其中,用 left<0 控制窗口长度。第一步入右端点后，此时长度恰好满足窗口大小。出左端点破坏窗口大小。

## 二叉树

### DFS 自顶向下

自顶向下，即**先序遍历**，优先遍历根。

### DFS 自底向上

自底向上，即**后序遍历**，最后遍历根。本质上，是先收敛到叶。

```
"""
这种写法的自底向上，本质上是递归收敛到叶子结点再统计。
"""
def maxDepth(self, root: Optional[TreeNode]) -> int:
   if root is None:
      return 0
   left_depth = self.maxDepth(root.left)
   right_depth = self.maxDepth(root.right)
   return max(left_depth, right_depth) + 1
```

自底向上的思维要求较高，需要把握在叶子结点收敛时的微操作，以及'超级操作'

```
def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
        # 微操作 在中间层以及叶结点收敛时的操作
        if root == None:
            return True
        if root.left and root.left.val != root.val:
            return False
        if root.right and root.right.val != root.val:
            return False
        # 超级操作
        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)
```