# THREAD

## 导读

进程的提出使操作系统在宏观层面实现了多个应用的并发执行,这种并发是通过操作系统不断地切换进程来达到的.
对于单核CPU而言,任意时刻只有一个进程被OS调度在CPU上执行.目前而言的并发仅仅是进程之间的并发,而对于一个进程内部还没有并发的体现,这也是提出**线程**的起因,即提高一个进程内的并发性.

> thread由贝尔实验室提出,Dijkstra和其他人提出了管程

对于很多以单一进程的形式运行的应用而言,逻辑上可以由多个可并行执行的任务task组成,如果其中一个被阻塞将导致整个进程被阻塞.这降低了并发执行效率.
因此如果能把进程内多个可并发执行的任务通过一种更细粒度的方式让操作系统进行调度就可以在进程内实现并发执行.

简单地说,线程是进程的组成部分,进程可以包含1~n个线程.
同属于同一个进程的线程共享进程的资源,包括地址空间,打开的文件.
线程基本上由线程id,执行状态,PC,寄存器集合与栈组成.
是可以被操作系统或用户态调度器独立调度(Scheduling)和分派(Dispatch)的基本单位.

至此,在提出了线程后,进程就变成了线程的资源容器,而线程成为了程序的基本执行实体.

## 线程

进程的主要目的是隔离,而线程的引入强调了共享,即属于同一进程的多个线程可共享进程的资源,这也意味着有同步问题需要解决.

线程是作为进程内部的抽象.在线程提出之前,一个进程在一个时刻只有一个执行点（即PC值域栈的位置）,而引入线程后每个线程都有一个执行点.这些线程共享进程的地址空间,所以不必采用较为复杂的进程间通信机制也可以很方便地访问进程内的数据进行协作.

与进程类似,线程也需要保存一组寄存器值作为**上下文**,即PC值域通用寄存器的集合,同时需要一个栈来保存函数调用站与局部变量.如果两个线程运行在一个处理器上也需要类似进程切换的调度机制,在一定的时刻进行进程切换并进行上下文的保存与恢复.至此一个进程的多线程可以独立运行并取代了进程成为了OS调度的基本单位.

### 结构

由于把进程的结构进行了细化,通过线程来表示对处理器的虚拟化,使得进程成为了管理线程的容器.进程中的线程没有父子关系,所有人都是兄弟,但有一个老大表示创建进程时第一个建立的线程,即主线程.类似于PID,每个进程也有在所属进程内生效的线程标识符(TID);同进程下的两个线程TID不同.主进程由于最先被创建,TID固定为0.

### 简单的线程模型

- 拥有三种状态：就绪,运行,阻塞
- 所有线程共享进程的地址空间和其他共享资源
- 可以被OS调度
- 可以动态创建和退出
- 线程无父子关系
- main函数运行在主线程上,主线程退出后整个进程退出,其他线程也一同退出
- 可以通过系统调用获得OS服务,但线程和进程的sys_call不能混用
  
线程模型建立在进程的地址空间抽象之上,所谓共享进程的地址空间,指代码段数据段等,或者说共享同一个内存映像.
从逻辑上而言某些段由所有进程共享(如.bss和.data),但某些段是由某个线程独占的(如OS为每个进程分配的栈).通常而言程序员会遵守这种约定保证其独占性,但线程之间不能严格地做到隔离.一个线程访问另一个线程栈的行为不会被禁止.
这体现了线程和进程的不同,即线程的诞生是为了方便共享,而进程更强调隔离

线程模型同样需要操作系统支持一些系统调用例如创建进程,等待进程与结束进程.

### 线程调度

在资源调度单位从进程变化为线程,调度器就要考虑更多的因素.
当一个线程时间片用尽而交出CPU使用权时,切换到同进程还是不同进程的线程的上下文切换开销往往有很大的不同,可能影响到是否需要切换页表.

当然更为简单的调度策略是对所有线程一视同仁,不考虑他们属于哪个进程

## 同步互斥

多线程对共享资源的访问天然需求某种互斥性,当一个线程对共享资源进行操作的时候,共享资源处于不合法的中间状态,一旦其他进程在此时开始操作就会产生未定义的行为.只有当操作完成,共享资源重新回到合法状态之后,其他线程才能开始下一次操作.

线程对共享资源进行操作的那部分代码称作**临界区**(Critical Section).
为了正确性必须要满足**互斥**(Mutual Exclusion)访问要求,即同一时间最多只能有一个线程在这种共享资源的临界区之内.

**Mutex**锁这一名字取自Mutual Exclusion的首字母.

### 原生互斥

对于一些简单的原生共享数据类型,比如64位unsigned int,现代指令集架构额外提供了**原子指令**(Atomic Instruction),如果能够把临界区缩小为一条原子指令,此时这已经是处理器执行指令和时间片切分的最小单位,那么我们不使用任何保护手段也能满足互斥要求.

但原子指令通常只能保存但内存位置上的简单操作,比如A=A+1;当资源较为复杂时就无能为力了.

### 锁

锁的两个基本操作室上锁和解锁.在线程进入临界区之前和退出临界区之后分别需要上锁和解锁来保证临界区的互斥性.

1. 上锁,检查共享资源是否已经上锁,如果有则等待持有钥匙的进程归还钥匙并解锁.否则就将资源上锁,此时称该进程获取到了锁或者持有锁,拿走钥匙进入临界区
2. 在临界区内访问共享资源.只有持有锁的进程能够进入.
3. 解锁,在离开临界区之后将资源解锁并归还,称释放了锁

### 同步与互斥

同步(synchronization)和互斥(Mutual Exclusion)是多线程并发访问过程中出现的两种不同需求.同步指的是线程执行顺序上的一些约束,比如B必须等待A执行完毕后才能执行.互斥指的是多线程在访问共享资源时对临界区的互斥访问控制.
但其实两者的界限比较模糊,互斥也能看成是一种同步需求,二者是相互包含的关系.
我们统一称这两种需求为**同步互斥**,针对这种需求提出的较为通用的解决方案称**同步互斥原语**(Synchronization Primitives).

### 信号量

信号量(semaphore)也是一种同步原语,功能比互斥锁更为强大,描述了线程在某个时刻占用的某种资源.

### 条件变量

互斥锁和信号量两种同步原语比较复杂,对程序员的要求较高.如果使用不当就有可能导致效率低下或者产生竞态条件,死锁和不可预测的情况.
为了简化编程,一种抽象层级更高更易于使用的同步原语**条件变量**机制被提出.

### 管程

用信号量和互斥锁的组合并不是一种通用的解决方案
- 信号量本质是一个整数,不足以描述所有类型的等待条件
- 信号量使用时需要特别小心,PV配对使用,以及注意与互斥锁组合的操作顺序

针对这种情况,结合操作系统和编程语言提出了一种**高级同步原语**,**管程**(Monitor).管程是一个由过程(函数),共享变量与数据结构组成的集合,体现了面向对象思想.编程语言负责提供其底层机制,程序员可以根据需求设计自己的管程,包括自定义管程中的过程和共享资源.
在管程的帮助下线程可以更方便,安全,高效地进行协作,线程只需要调用管程中的过程(函数)即可.管程中的共享资源不允许直接访问,而只能通过管程中间接访问.这是在编程语言层面对共享资源的一种保护,类比C/JAVA的私有成员.

早期提出的管程是基于Pascal语言设计的,其他语言如C和Rust并没有在语言上支持这种机制.对此我们的做法是从管程中将比较通用的同步原语——条件变量抽离出来,再将其与互斥锁组合使用(通过手动加锁解锁来代替编译器)来模拟原始的管程机制.在目前的C语言应用开发中实际上也是这么做的