# XV6
## 随便写写
### 系统调用与完备的异常处理程序

系统调用由用户侧发起,当用户发起一个系统调用,系统将执行一段汇编指令;
汇编指令将系统调用号传入寄存器a7,将参数传入对应的寄存器,然后执行ecall(environment call);
ecall是RISC-V中的一类trap,trap会将修改模式为特权态,并在stvec寄存器里写入trap处理程序的地址;这个地址会被复制到PC,随后跳转去对应的系统调用函数.
RISC-V架构下的trap在跳转时并不保存除PC以外的任何寄存器(PC保存在sepc),保存上下文的工作需要trap程序自行实现.
在较为简单的情形使用epc寄存器返回是可以的,比如8号异常系统调用就是使用epc来保存返回地址,返回地址为下一条指令.
但对于一些复杂情形epc会被覆写,保存上下文仍然是必要的.
为了让trap的异常处理程序(该情境下为所执行的系统调用函数)能够正常返回到用户侧的正确位置,我们需要保存上下文信息.
xv6为每个进程定义了一个trapframe结构体表示当前寄存器的一个状态;
为进程新增一个pre_trapframe,用来保存一个寄存器状态,在处理函数返回时使用它来恢复状态.

>backtrace
通过寄存器s0(p->trapframe->s0)得到一个指向栈帧的指针
该指针-8和-16将得到返回地址与上一个栈帧指针

### 进程页表

xv6使用三级页表,直接地址映射;

内核空间内存在一个内核页表kernel_pagetable,但仅限于内核空间的映射,无法处理来自用户地址的指针.
在原先的实现中,用户进程切入内核态后需要通过一个特殊的函数模拟硬件寻址来翻译出用户地址对应的真实物理地址;我们希望为每一个进程实现自己的页表,从而进入内核态后直接使用当前进程专属的内核页.
首先要为进程结构中加入自己的pagetable,并为其分配专属的内核页.
SATP(supervisor address translation protection)寄存器用于控制地址转换与保护,
修改调度器scheduler,在进程切换时就把进程的专属pagetable放入SATP,从而使用它的页表进程地址映射;在进程销毁时,释放这个页表.

### 懒分配优化

当进程申请堆区内存时,不直接分配物理地址,而是当发生缺页异常时再分配,只修改proc->sz;
缺页异常对应13和15号异常.
异常发生后,系统会执行trap进入内核态,此时根据接收到的异常号进行异常处理.
当识别到缺页异常时,手动分配物理页,并完成虚拟物理空间的映射.

