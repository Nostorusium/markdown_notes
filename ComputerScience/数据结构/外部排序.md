# 外部排序

在数据量很大的情况下，我们无法将所有数据载入内存。因此当考虑外部排序，我们就“看见了”磁盘块。

## N路归并排序

归并排序的想法是令磁盘块内有序，并将有序的小块逐渐组织成有序的一组小块构成的大块。以二路归并举例，假如一个磁盘块能存储2个值。

```
block1: 1,5
block2: 2,4

block3: 3,6
block4: 4,8
```

二路归并，则每次选择两个“块”进行归并排序。所以选择1,2块/3,4块排序:

```
block1: 1,2
block2: 4,5
-----------
block3: 3,4
block4: 6,8
```
此时我们构成了两组内部有序的“大块”。尽管在大块的内部是由有序的小块逐渐构成的，但对于任意两个有序的数组进行排序总是简单的，所以我们可以放心于内部块的分裂，而把这一组块视作逻辑上的统一有序块。  

更细节的说，这样的排序要如何实现呢？块位于磁盘上，而我们处理数据总是在内存。因此我们通常准备N个输入缓冲区用来读取N个块到内存，缓冲区的大小与磁盘块保持一致。同理，排序好的数据要写回磁盘，我们需要若干输出缓冲区。通常而言，输出缓冲区只需要1个就足够了，但你若是希望拥有更好的并行性，也可以令输出缓冲区也为N个。  

此时我们注意到，尽管经过多轮归并形成的大块是由若干基本磁盘块构成的，可是对两个有序的大块进行排序，仍然只需要2个输入缓冲区就足够了。只需要分别拿入各自的最小块，并输出最小块，有序地回到磁盘就可以了。但这也意味着，不管每一轮归并合并了多少个“大块”，其归根结底还是要根据小块进行排序，所以每一轮都需要访问所有的基本磁盘块，读写各一次。

>假如有16个磁盘块，则我们需要 $log_216=4$ 轮归并。每一轮归并需要读写16个磁盘块各一次，所以一共需要 4*32 = 128次。

对于更一般的N路归并，我们有总合并次数 = $log_N(blocksize)$ **向上取整**。第一轮将最基本的磁盘块归并为**归并段**的操作叫做预处理，或者初始化。在初始化之后的归并次数 = $log_N(归并段数)$

显然，当N更大，我们需要归并的次数就更少，也有更少的磁盘访问次数。但要注意到N的增大也会导致内存中的输入缓冲区增大。

## 败者树

在**N路归并**的过程中，当选入N个块进入输入缓冲区进行比较，若要选出一个最小值需要进行N-1次比较，比较的次数随N增长而增长。每趟我们需要确定O(n(k-1))数量级的比较，过高。我们引入败者树加快这个比较。

**败者树**本质上是一个数组，其用父节点记录器左右子节点比较的败者，并让胜者参加下一轮比赛。我们只在a[0]保存唯一的一个胜者，即最小值所在的归并段，其他结点均为失败者。这同样意味着非a[0]的高层结点在较后位置失败，它在局部位置是胜利者。  

此处我们不详细探讨败者树的建立与输出，只需知道一旦构建好了败者树，再选择一个最小元素只需树高h = $log_2N$，树高不包括a[0]与叶子结点。这是一个令人接受的数量级。

## 置换-选择排序

对于N路归并排序而言，预处理获得的归并段是取决于磁盘块数与N，每一个初始归并段都均可能均分。之后我们在内部有序的归并段之上继续做排序。总归并次数 = $log_N(归并段数)$ ，若是我们能在初始化归并段时**让归并段内更长**，就可以**减少归并段数**，**减少归并次数**。  

我们在内存开辟一个工作区WorkArea，其大小为w。我们在无序的输入文件FileInput中选择值加入内存工作区WA。起初WA为空，选择w个值加入WA，此时我们记录最小值为MINIMAX，并将其输出到一个归并段内。随后，再补充1个值加入WA，并取大于MINIMAX的最小值为新的MINIMAX，然后按照同样的规则输出。  

MINIMAX的值会逐渐增大，我们永远输出比MINIMAX更大的最小值，一旦我们找不到比MINIMAX更大的值，即WA中所有值都比MINIMAX小，我们认为这个归并段构建完成。从零开始构建下一个归并段，直到WA为空。  

MINIMAX的巧妙在于，我们在构建归并段时是根据从小到大排序的，因此MINIMAX应当逐渐增大以满足从小到大的增长。而我们希望这个增长速率是克制的，不要过快的增长，因此我们只取超出MINIMAX的最小值。  

## 最佳归并树

最佳归并中，我们保证每一轮归并对应的树是一颗N叉哈夫曼树。这样一棵N叉归并树，只有度为0和N的结点。

>假设外存上有80个初始归并段，进行8路归并时，为了实现最佳归并，需要补充多少虚段?
> $n_0 + n_8 = 8n_8 + 1$
> 其中, $n_0 = 80 + n_虚$
> 可解 $80+n_虚 = 7n_8 +1$
> 令 $n_8 = 12$，有最小 $n_虚 = 5$