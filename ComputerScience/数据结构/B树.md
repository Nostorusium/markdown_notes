# B树与B+树

在过往提及的各种排序，都是在内存中进行比对的。而对于更大的数据量，以至于无法在内存中处理，我们只能将其存放在硬盘上。  

众所周知磁盘IO是慢速的，如果采用树形结构排序，则IO次数取决于树高。对于内存中的数据这是可以接受的，但对于磁盘上的数据比较，我们自然的希望减少数的高度从而减少访问磁盘。  

B树就是一种延长了结点的信息量，缩短了树高的n叉平衡搜索树。

## B树

B树的阶,即结点最多有几个子节点。
- 对于n阶B树，要求除了根以外的所有结点不得超出n个子树，即节点内部不得超过n-1个关键字。
- 除根以外的分支节点,至少有 $\lceil n/2\rceil$ 棵子树,$\lceil n/2\rceil-1$个关键字。

所以一棵n阶B树，分支节点的子树范围是： [$\lceil n/2\rceil$ , n]  
即除了根以外的结点只能拥有 [$\lceil n/2\rceil-1$ , n-1] 个关键字。

因为我们希望每个结点能多包含一些信息，所以得到了一个关键字下限，来把树的高度均摊得更矮。同时，他还要保证n叉树的特征，即上限不超过n。

## 插入

如果插入的关键字导致结点上溢，通常取中间元素 $\lceil n/2\rceil$ 为分界将其分成左右两个子结点。中间元素向上传递给父节点。  

如果父节点再次溢出，则继续向上传递，最坏情况下这种溢出会传递到根，并在根之上建立新根。

## 删除

删除会导致结点下溢。我们需要保证有序性的同时，从左右兄弟借一个来满足不下溢。而由由于需要保持有序性，需要和父中元素交换一下。

若左右兄弟在借出结点后自身也下溢，我们此时认为当前下溢结点和不够借的兄弟结点加上父节点中的一个元素可以**合并为一个新结点**。所以结点合并，父元素下移。

## B+树

B树为我们提供了一个良好的随机存取性能，即限制了树高，限制了IO次数。B+树则提供了顺序存取的良好性能。B+树的叶子结点被串联在一起，提供了一个有序的顺序存储。并且叶子结点将指向一个具体的记录，因此它常被用于数据库，来指向某个数据库表。

B树本质上在进行搜索，在搜索结束后抵达了“叶子”结点我们认为磁盘上并没有所需元素，搜索失败。而B+树本质上在进行索引，它的结点关键字不再是用作比大小分流，而是直接对应一棵子树。  

因此对于一个n阶B+树，结点最多有n个子树，对应n个关键字。而其下界与B树保持一致，并无变动。