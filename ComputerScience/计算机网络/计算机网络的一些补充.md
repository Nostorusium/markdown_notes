# 补充

## 物理层与信息传播

当视野来到了物理层，我们所见之物全然没有任何高层抽象，只有赤裸的物理工程实践。  
信息传输问题从高层抽象的网络工程设计还原为了最基础的信息通信问题。  

### 码元，波特率，比特率

信息在一条物理信道上传输，它被信号承载。信号可以是离散的数字信号，也可以是连续的模拟信号。在物理/数学上，他们都表现为波，模拟信号为正弦波，数字信号为方波。  

如何使用波来传递信息呢？就好比编码，我们也可以使用几个比特编码几个波形。  
2bit能表示4个波形，此时一个特定的波形就承载了2个比特的信息。我们使用术语**码元**来称呼这样的波形。  

数据的传输速率就变成了单位时间能放出这样波形的个数。我们使用**波特率**表示单位时间内传输的码元个数。  

而当信息还原为比特，我们就得到了**比特率**，它在数值上为 **波特率*logN**

### 信息论，奈氏准则与香农定理

香农的信息论诉诸了一个道理：任何形式的**信息**都不能无限快的传播。  
奈氏准则与香农定理从两个不同角度阐述了他们的理由。

**1. 奈氏定理**

数学上的各类关于波的叠加与变换被应用于模拟信号的实际传播：即多个正弦波的叠加。接收方在接受这样的信号需要进行采样，以一定频率进行采样并尽可能恢复原始的模拟信号。**采样定理**给出了采样频率应该大于模拟信号中各个信号分量重最高频率的两倍。这是技术上为了避免无法确定信号波形提出的。  

这意味着如果信号频率过高，接收方以既定的采样频率不能很好的确定码元之间的界限，即码间串扰。为了避免这种情况发生，发送码元的速率应该有所限制。  

奈奎斯特给出：理想信道下，极限码元传输速率为**2W**(两倍带宽)，对应比特率**2WlogN**  
要注意，这是因为码元，或者说波形的传输问题招致的**波特率**限制，而并没有对每个波形承载的比特作出限制。也意味着，如果编码方案足够优秀使得一个码元能承受更多的比特，那就可以提高比特率。

**2. 香农定理**

奈氏定理揭示了码元在实际传输中遭遇的问题，它是在理想信道中设想的，它给出了波特率限制。  
香农则给出了在有噪声信道下，信息传输的比特率限制：
$Capacity = W*log_2(1+S/N)$
其中，S/N为信噪比，它还可以表示为**分贝值**：$10*log_{10}(S/N)$，单位为db。  

香农定理揭示了由于实际存在的噪声，我们无法拥有理想信道，也无法在理想信道下通过提高码元比特承载量的方式无限快地传输数据。

## 滑动窗口

值得说明的是，滑动窗口只是一种指导思想，而不是某种特定的具体实现。  

提到**广义的滑动窗口**，不管是GBN还是SR，都按照具体编号判断接受的分组。此处我们使用广义术语：**分组**，因为他可以被实现在不同层。在TCP/IP下往往在传输层进行流量控制，所以此时这个分组是**传输层报文**。在ISO下，往往在链路层进行流量控制，此时这个分组是**帧**。  

流量控制中涉及到一个特殊情形：即接收方接受了分组，并向后推进了窗口，同时返回ACK给发送方。而发给发送方的ACK中途丢失，导致接收方的窗口已向后推进，发送方迟迟收不到ACK而阻塞窗口直到定时器重传未确认的帧。如下图：

```
suppose Ws = 5
sender:         (0 1 2 3 4) 5 6 7 0 1 2 3 4 5 6 7
ACK:             x x x x x
receiver:        0 1 2 3 4 (5 6 7 0 1 2 3 4 5 6 7 ?)
```

如图的情景中，发送方因为迟迟收不到ACK，最终重新传送帧 0~4 。而要注意此时接收方的窗口已经向后递进，在此情景下的序号范围里，我们应该控制接收方的窗口大小，至少保证窗口内的序号不会与重传的 0~4 冲突。  

因此接收方窗口只能限制在5 6 7，决不能越过这个范围包括后续的0,1,2...不然将导致重传的旧0,1,2与接收方窗口内待接收的新0,1,2...产生序号冲突。  

在这个例子中，接收方的窗口将被限制在3。  
将这个例子一般化，我们会得到：发送窗口 + 接收窗口 不得超过 序号范围。
假如我们有n比特编号，那么序号值将为 $[0,2^n-1]$ ，一共 $2^n$ 个数。  
我们得到 发送窗口 + 接收窗口 ≤ $2^n$。  

现在我们得到了一般的滑动窗口要遵循的序号要求。特别地，我们可以看看在GBN与SR情况下他们的序号情况：

1. GBN
   如果用滑动窗口来解释GBN，那么它可以被理解为一个发送窗口为n，接受窗口为1的滑动窗口协议。遵循n+1 ≤ 序号范围。
2. SR
   同理，SR可以被理解为一个发送窗口等于接收窗口的滑动窗口协议。遵循n+n ≤ 序号范围，即所谓的n至少为序号范围的一半。

### TCP流量控制与GBN和SR

TCP的流量控制既不是GBN，也不是SR，而是两者的缝合。

- **GBN**的特点
  GBN的特点是要求分组抵达的有序性，不接受乱序分组。
  如果一个乱序分组抵达接收方，接收方将直接抛弃，并保持原ACK。
  在这个意义上，我们可以认为GBN的接收窗口为1。
  由于要求有序性，GBN会重传一组已发送未确认的分组来保证不失序。
- **SR**的特点
  SR比起GBN的优点在于它不强制要求分组抵达的有序性，而是在接收侧保持较大的缓存（接收窗口），暂存乱序分组。
  接受方会递交部分有序抵达的分组，并向后推进窗口，并允许对乱序分组发送ACK。
  由于允许乱序性，当分组ACK超时，发送方只会发送超时的分组。
- **TCP的流量控制**
  TCP的缝合在于，一方面它如GBN一样使用累积ACK，只发送有序分组的最后一个ACK作为确认。而另一方面，他又如SR一样在接收方保存失序分组，并且重传时只重传超时分组。

## 链路层争用期

为了保证能够检测冲突，帧长不能过短导致在检测到冲突之前就很快就接收完毕。
这个检测冲突的期限为争用期，最常见的争用期为RTT。

关于碰撞检测的期限要求，是做了如下考虑：
1. 假如两个设备在链路上同时向对方发送数据，他们在链路的中间发生了碰撞。当数据抵达到对侧设备时，设备就能检测到发生了冲突。此时只需要一个传播时延。
2. 假如一个设备刚刚要发送数据时也接受到了对侧设备发送的数据，这两个帧发生了冲突。那么该设备可以立马检测到冲突，而对于对侧设备而言，他必须等到该设备发送的帧也抵达它那里才能检测到冲突。对于对侧设备，从它发送前一帧，到收到后一帧，已经过去了两个传播时延，即一个RTT。它检测到后收到的帧发生了碰撞，就知道该碰撞是由于自己发送的前一帧在极端情况下引发的。

因此，如果做最坏考虑，我们通常取一个RTT的时间才能检测到碰撞。如果中途有延迟，则需要更久。
最短帧的长度由 **争用期** * **发送速率** 决定。


## 802.11无线局域网与CSMA/CA

以太网所使用的CSMA/CD是基于**碰撞检测**的，即只要信道空闲就发送，若中途发生冲突则立刻停止传输，并指数退避选定一个时间量后重传。而IEEE802.11 无线局域网，即WiFi采用CSMA/CA作为接入协议，基于**碰撞避免**。由于无线信道相对较高的比特差错率，使用链路层确认/重传ARQ方案。

802.11之所以不使用**碰撞检测**，是因为检测碰撞要求站点具有同时发送和接受的能力。

而在802.11适配器上，接受强度通常远小于发送强度，构建具有碰撞检测能力的硬件代价很大。并且，即便实现了碰撞检测，适配器额会由于隐藏终端问题和衰减问题无法检测到所有碰撞。

这意味着WiFi站点一旦发送一个帧，它就完全地发送该帧，不会返回，即便发生了碰撞。

### CSMA/CA协议

当无线局域网中某个站点发送一个帧，该帧会由于多种原因不能无损的抵达站点。因此目的站点需要进行校验，等待一个**短帧间间隔**(Short Inter-frame Spacing)，**SIFS**后返回确认帧。发送方若在给定的时间内未收到确认帧则认为该帧错误并重传。

假设一个站点(无线设备，或者AP)有一个帧要发送：

1. 如果站点监听到信道空闲，则在一个被称作**分布式帧间间隔**(Distributed Inter-frame Space)，**DIFS**的短时间段后发送帧。
2. 若不空闲，选取一个随机回退值，并在侦测到信道空闲时削减该值，直到零时发送。若信道忙，则不削减计数值。
3. 当收到确认帧，传输站认为该帧已被目的站正确接收了。若还有后续的帧要传输，则从第二步开始，不再重复发送DIFS，而是继续按照SIFS间隔发送数据帧/确认帧。

对比CSMA/CD一旦侦听到信道空闲就立刻发送，CSMA/CA选择一个回退值，当计数归零才发送。
>考虑一个这样的情景：A，B分别有一个数据帧要发送，此时C已经传输，所以A与B并未立刻发送。若使用CSMA/CD，当C传输完毕，AB将立刻发送帧，此时发生碰撞。而CSMA/CA并不检测碰撞，这个碰撞的帧将被完全传输。如果CSMA/CA要尽可能的避免这样的碰撞，我们总希望A，B能选择到两个不同的回退值，如果确实不同，那么A与B将会先后发送帧。先发送的帧导致了信道忙，并冻结了后发送站点的计时器，延迟了后者的发送时间，这样尽可能避免了碰撞。
>不过802.11仍然可能发生碰撞，比如两个站点隐藏，不能看到彼此，或者两者选择了非常靠近的回退值。

### 隐藏终端问题与RTS/CTS

考虑A,B两个无线站点与AP。A,B同时在AP的覆盖范围内，而A与B不在彼此的覆盖范围内。这意味着A，B两个站点对彼此不可见，这会造成一个问题：A与B只能在各自的覆盖范围内检测信道是否空闲，这意味着如果A正在传输一个帧，B将无法侦测到A的传输，在等待一个DIFS后B也开始传送帧，随后产生一个碰撞。

为了避免这一问题，IEEE802.11协议允许使用短 **请求发送(Request to Send,RTS)** 与 **允许发送(Clear to Send,CTS)** 两个控制帧来预约对信道的访问。  

请求发送RTS相当于一个信道预约请求，当无线站点将RTS帧发送给AP，在该帧中指示传输数据帧和确认帧所需要的总时间，然后由AP广播CTS帧作为相应。CTS帧相当于接受这个预约，并通知其他站点不要在该预约期内发送数据帧。  

尽管RTS/CTS控制帧减少了碰撞，但同时引入了时延，消耗了信道资源。因此RTS/CTS仅仅用于**长数据帧**预约信道。对许多无线站点而言，默认的RTS门限值甚至超过了最大帧的长度，则对于所有发送的数据帧都不使用RTS/CTS控制。

### AP帧的三个地址

一般使用三个地址来标识帧的身份：
- addr1:目的地址，我要去哪。
- addr2:原地址，我是谁。
- addr3:三者中的另一个。

(addr1,addr2) 首先给出链路帧需要的基础信息：目的地址与源地址。最后，addr3表示所处AP范围。举例一个AP范围内有A，B两台主机,A经过AP与B通信。那么,
- A->AP的帧,地址将是:(AP,A,B)
- AP->B的帧，地址将是：(B,AP,A)


## 自治系统与自治系统路由

### 内部路由选择

**OSPF**最短路有限是一种链路状态协议，被广泛用于AS内部的路由选择。每台路由器都构建了一幅关于整个自治系统的完整拓扑图，并在本地运用Dijkstra最短路径算法。  

使用OSPF的一个重要原因是，随着路由器数目变得很大，涉及路由选择信息的通信，计算和存储开销将高的不可实现。在所有路由器之间广播连通性和链路开销的负担是巨大的，在如此大量的路由器中迭代距离向量算法肯定永远无法收敛。

>实际上你依然可以看到路由器很少的自治系统内仍使用RIP距离向量算法。

### 外部路由与BGP

OSPF是一个AS内部路由选择协议，而当分组跨越多个AS进行路由，我们需要一个**自治系统间路由选择协议**。在因特网中，所有AS都运行相同的AS间路由选择协议：**边界网关协议(Broder Gateway Protocol,BGP)**。

在BGP中，分组并不是路由到一个特定地址，而是路由到一个**CIDR化的前缀**，其中每个**前缀表示了一个子网或子网的集合**。一个目的地可以采用138.16.68.22/22的形式，在这个例子中这包括1024挑个IP地址。因此以太路由器的转发表将具有形式为(x,I)的表项，x是一个前缀，I则是该路由器的接口之一。  

作为一种AS间的路由选择协议，BGP为每台路由器都提供了完成一下任务的手段：
1. 从邻居AS获得前缀的可达性信息。
   特别地，BGP允许子网向因特网的其他部分告知它的存在，BGP确保所有AS直到该子网。
2. 确定到该前缀的最好路由
   一台路由器可能知道两条或者多条到达特定前缀的不同路由

### 传递可达性信息

考虑三个自治系统，AS1，AS2，AS3按顺序连接。AS3具有一个前缀为x的子网，在高层次上，AS3向AS2发送BGP报文，告知x存在并且位于AS3，表示为 "AS3 x"。然后AS2向AS1发送一个BGP报文，告知x存在并位于AS3，并且能够先通过AS2抵达AS3，报文表示为“AS2 AS3 x”。以这种方式，每个自治系统都知道x的存在，并且知道通向x的路径。  

更具体的说，在自治系统中，每台路由器要么是一台**内部路由器**，要么是一台**网关路由器**。网关路由器位于AS边缘，直接连接到其他AS中的一台或多台路由器。在BGP中，每台路由器都是用179端口的半永久TCP连接交换路由选择信息。每条直接连接以及通过该连接发送的BGP报文称为**BGP连接**。跨越两个AS的BGP连接称作**外部BGP，eBGP**，不跨越AS的BGP连接称为**内部BGP,iBGP**。为了传播可达性信息，需要使用iBGP与eBGP会话。  

1. AS3的网关路由器先通过eBGP报文向AS2的网关路由器发送"AS3 x"。
2. AS2的网关路由器向AS2中的所有路由器发送iBGP报文"AS3 x"。
3. AS2的网关路由器向AS1发送eBGP报文"AS2 AS3 x"。
4. AS1的网关路由器最后使用iBGP向AS1中所有路由器发送"AS2 AS3 x"。

在这个过程完成后，AS1，AS2中的每个路由器都知道了x的存在，也都知道了通往x的AS路径。

### 确定最好的路由

当路由器通过BGP连接通告前缀时，前缀中包含一些BGP属性。
- **AS-PATH**表示抵达前缀所经过的AS路径。
- **NEXT-HOP**表示AS-PATH起始的路由器接口的IP地址

一个比较简单的路由选择算法是**热土豆路由选择(hot potato routing)**。
热土豆路由选择算法总是选择从开始到NEXT-HOP最短的路径。其思想是，路由器要**尽可能快**地将分组送出其AS，而不担心AS外部到达目的地的余下部分。就其名字而言，分组被类比为烫手的**热土豆**。因为他烫手，你要尽快地将它传递给另一个人(另一个AS)。

在实践中，**BGP**使用了比热土豆路由更复杂，但结合了其特点的算法。对于任何给定的目的地前缀，BGP顺序地调用下列消除规则，直至只剩下一条路由选择。
1. 路由可以被指定本地偏好，具有最高偏好值的路由会被选择。
2. 从余下的路由中，选择具有最短AS-PATH的路由。即选择经过AS最少的路由。
3. 从余下的路由中，选择具有最靠近NEXT-HOP的路由。
4. 如果仍然余下多条路由，使用BGP标识符选择路由。

简单的说，**偏好**大于一切，优先选择**AS路径短**的，次优先选择**挨着近的**网关路由，最后自己看着办。