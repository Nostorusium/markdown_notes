# CSAPP章节小结

## 第八章 异常控制流

指令被一条一条地执行,程序计数器有着一个值的序列：a0,a1,...ak
每个ak都对应着一条指令Ik的地址.由ak向ak+1的过渡称**控制转移**.
这样的控制转移序列,即**处理器的控制流**(flow of control/control flow)

简单的控制流是平滑的连续序列,每个指令Ik与Ik+1之间都是相邻的
这种平滑流的**突变**,即Ik与Ik+1不相邻通常由**跳转**,**调用**,**返回**等造成

系统也必须要能对**系统状态**的变化做出反应,这些系统状态**不是**被内部程序变量捕获的,也不一定要与程序的执行相关:如**硬件**造成的突变

现代系统通常**使控制流发生突变**来对这些情况做出反应,称这些**突变**为:
**ECF**(Exceptional Control Flow)**异常控制流**

### 异常

异常(exception)由**硬件**与**操作系统**共同实现
它就是控制流的突变,用来相应处理器状态中的某些变化.

系统为可能的异常都分配了一个唯一的非负整数**异常号**
处理器得到设计者分配一些,操作系统内核分配一些
系统启动时,操作系统要分配和初始化称**异常表**的**跳转表**,表示了各个**异常处理程序的地址**
当捕获到异常,就可以确定相应的异常号,然后触发异常,查表跳转到异常处理程序

- 异常表的起始地址存放在**异常表基址寄存器**(exception table base register)
- 异常处理程序运行在**内核模式**下
- 类似过程调用,但根据异常类型,其返回地址要么是**当前指令**,要么是**下一条指令**

有四种类型
|类别|原因|同步/异步|返回
|:-|:-|:-|:-|
中断 interrupt|来自I/O设备信号|异步|下一条指令
陷阱 trap|有意的异常|同步|下一条指令
故障 fault|潜在可恢复的错误|同步|可能返回到当前指令(重新执行)
终止 abort|不可恢复的错误|同步|不返回

#### 中断

中断是异步发生的,是来自处理器外部的I/O信号的结果
**硬件中断**不由任何指令造成,硬件中断的**异常处理程序**常常叫做**中断处理程序**(interrupt handler)


1. 执行某指令时，I/O设备把异常号放到系统总线触发中断.
2. 在当前指令执行完成后,处理器注意到中断,读取中断号,执行其对应的中断处理程序
3. 处理程序返回,控制回到刚才指令的下一条指令

程序会继续向后执行指令,就好像没有发生过中断一样

#### 陷阱

陷阱最重要的用途是在用户程序与内核之间提供一个像过程一样的接口:**系统调用**
用户程序向内核请求服务,处理器提供了syscall n 指令
该指令会导致一个到异常处理程序的陷阱,该异常处理程序解析参数,调用适当的内核程序

1. 应用程序执行了一次系统调用
2. 控制传递给处理程序
3. 陷阱处理程序运行
4. 处理完成后返回给下一条指令

之所以认为陷阱是异常,即"控制流的突变",是因为使用了区别于用户态的内核提供的服务

#### 故障与终止

由错误情况引起,可能被故障处理程序修正
如果可以修正,就返回引起故障的指令重新执行
否则将返回到内核的abort,引起**终止**

### Linux/86-64系统调用过程

```
int main(){
    printf("hello,world\n");
    return 0;
}
```
C程序用syscall函数直接调用系统调用,而对于大多数系统调用标准C库提供了包装函数.
这些包装函数将参数打包在一起,以适当的系统调用陷入内核,再返回回调用程序
其系统级函数版本如下
```
int main(){
    //arg1表示输出发给stdout
    //arg2表示要写的内容
    //arg3为要写的字节数
    write(1,"hello,world\n",13); 
    _exit(0); //return 0
}
```
汇编如下
```
.section .data
string:
    .ascii "hello,world\n"
string_end:
    .equ len, string_end - string

.section .text
.globl main
main:
    movq $1 %rax        //write的系统调用号是1
    movq $1 %rdi        //参数1
    movq $string,%rsi   //参数2
    movq $len,%rdx      //参数3
    syscall             //执行系统调用

    movq $60,%rax       //_exit的系统调用号为60
    movq $0,%rdi        //参数1
    syscall             ////执行系统调用
```

### 进程

**异常**允许了操作系统内核提供**进程**(process),允许控制流在不同程序之间乱跳

而对于程序自己而言仿佛在独占地使用处理器与内存,
处理器仿佛在无间断地执行程序中的指令,其代码与数据防腐蚀系统内存中的唯一对象
这些假象都由**进程**提供

其经典定义为:一个执行中的程序实例
每个**程序运行在**某个**进程的上下文**(context)中
上下文由运行它所需要的**状态**组成,包括 内存中的代码与数据,栈,通用寄存器的内容,PC,环境变量,文件描述符等

在shell中输入一个可执行目标文件的名字,运行程序时就会创建一个新的进程,在这个进程的上下文中运行它。

进程给应用程序提供了关键抽象:
- 独立的逻辑控制流
- 私有的地址空间

#### 逻辑控制流

程序运行时一系列PC的值唯一对应了包含可执行目标文件中的指令,或者动态链接库中对象的指令
这个PC值的序列叫做**逻辑控制流**

处理器的一个**物理控制流被划分成多个逻辑控制流**,
进程轮流使用处理器时,每个进程执行它的流的一部分然后被抢占(preempted),轮到其他进程
对于运行在进程上下文中的程序,看上去就仿佛在独占地使用处理器(只关注自己的逻辑流)

#### 并发流

如果两条逻辑控制流在时间上重叠,就称他们为**并发流**(concurrent flow)

并发并**不要求**处理器和数或计算机数,只要时间重叠就称并发
如果两个流并发地运行在不同的处理器核或计算机上,称**并行流**(parallel flow)

#### 私有地址空间

进程为每个程序提供了自己的私有地址空间,一般而言不允许其他进程读写
不过这样的空间有着相同的通用结构 P510 :经典的程序在内存中结构图

#### 用户模式与内核模式

处理器应该提供机制,**限制**一个应用可以执行的指令与可以访问的地址空间范围
这样操作系统内核才能提供一个无懈可击的进程抽象

处理器在通常在某个控制寄存器中的一个模式位(mode bit)提供这种功能
该寄存器描述了当前进程享有的特权
如果设置了模式位就认为其运行在内核模式(有时也叫超级用户模式)
不然认为在用户模式.不允许执行特权指令(privileged instruction)
用户程序只能通过系统调用接口间接地访问内核代码与数据

运行应用程序代码的进程初始运行在用户模式
其进入内核模式的唯一方法就是通过异常,执行异常处理程序(其在内核中)
返回后,处理器再把模式改回用户模式

#### 上下文切换

内核使用**上下文切换**(context switch)的异常控制流来**实现多任务**
上下文是内核重新启动一个被抢占的进程所需的状态,它由一些对象的值构成
内核抢占当前进程,重启先前被抢占了的进程,称**调度**
1. 保存当前进程的上下文
2. 恢复先前被抢占进程的上下文
3. 控制传递

#### 进程控制

进程ID:每个进程有唯一的正数ID
```
pid_t getpid(void);     //返回调用进程ID
pid_t getppid(void);    //返回父进程ID
```

创建与终止:进程总是处于下面三种状态之一
- **运行** 要么在被执行,要么在等待调度
- **停止** 执行被挂起,且不会被调度 保持停止
- **终止** 永远地停止:1.受到终止进程的信号 2.从主程序返回 3.调用了exit函数

```
void exit(int status);  //终止进程
```

子进程
```
pid_t fork(void);   //父进程创建子进程
```
子进程得到父进程的用户级虚拟地址空间的一个副本,包括数据代码段,堆栈,共享库,文件描述符
这意味着子进程可以读写父进程打开的任何文件
其最大的区别就是pid不一样

#### fork函数

fork被调用一次,却会返回两次
一次在父进程中,一次在新建的子进程中
```
int main(){
    pid_t pid;
    int x = 1;

    pid = Fork();
    //在子进程中返回0,这样就区分出程序在子进程执行还是在父进程执行
    if(pid == 0){
        printf("child : x=%d\n",++x);
        exit(0);
    }
    //父进程返回子进程PID,非零
    printf("parent ： x=%d\n",--x);
    exit(0);
}
```
结果:
```
parent : x=0
child  : x=2
```

- 调用一次,返回两次
- **并发执行**:子进程与父进程是**并发的独立进程**,内核可以凭喜好交替执行逻辑控制流中的指令 无法对不同进程中的指令交替执行做任何假设
- 地址空间**相同但独立** 进程地址空间只是内容相同(堆栈,变量,代码都相同),但独立,有各自的私有地址空间.对x的改变是独立的,不会反应在另一进程的内存中
- **共享文件** 子父进程都把x打在屏幕上,因为子进程继承了父进程所有的打开文件,当父进程调用fork时stdout文件时打开并指向屏幕,子进程继承它,输出也指向屏幕

画进程图 P515 将有助于理解嵌套fork调用的程序
```
int main(void){
    Fork();
    Fork();
    printf("hello,world\n");
    exit(0);
}
```
将创建4个进程

执行fork时,内核为新锦成创建了虚拟内存并标记内存区域为私有的写复制 但此时仍共享一个副本
直到随后的写操作触发写时复制,新进程获得了独立的物理页面


#### 进程回收

进程因某种原因终止时,内核并不立刻将其清除
而是保持在已终止的状态,直到它的**父进程回收**(reaped)它

父进程回收终止的子进程时,内核抛弃已终止的子进程,它不再存在.
终止了还未回收的进程成僵死进程(zombie)

如果父进程终止了,内核会安排**init进程**成为它的孤儿进程的养父
init进程的**pid是1**,系统启动时由**内核创建**,**不会终止**,所有进程的祖先
如果父进程终止时还有未回收的僵死子进程,则安排init去回收

对于长时间运行的程序(如服务器,shell),应总是回收他们僵死的子进程

waitpid
```
//默认返回子进程PID options=WHOHANG返回0 错误返回-1
//默认option = 0,
//挂起调用它的进程,直到**等待集合**中的一个**子进程终止**
//pid>0,表示等待该子进程终止
//pid=-1,表示等待父进程所有的子进程
pid_t waitpid(pid_t pid,int *statusp,int options);

//wait是简单版本,成功返回子进程PID 等价于waitpid(-1,&status,0)
pid_t wait(int *statusp)

```
option改为 WHOHANG,表示如果调用时任何子进程都没有终止,就立刻返回0,不等待

status参数的几个宏
```
//如果子进程调用exit或一个return正常终止,返回1
WIFEXITED(status);

//返回一个正常终止的子进程的退出状态 exit(int status)
WEXISTSTATUS(status);
```
#### 进程休眠

```
//让进程挂起指定的时间
unsigned int sleep(unsigned int secs);

//让调用函数休眠,直到进程收到一个信号
int pause(void);
```

#### 加载并运行

execve不返回 除非出错
```
//加载并运行可执行目标文件filename,带有参数列表与环境变量
//只有出错时返回,不然不返回
int execve(const char *filename,const char*argv[],const char *envp[]);
```
在execve加载了filename后,加载器(loader)设置启动栈,把控制传递给新程序的主函数main
```
int main(int argc,char **argv,char **envp)
```

#### 程序与进程

程序是一堆代码与数据,进程是执行中一个程序的实例
程序总是运行在进程的上下文中
fork函数在新的子进程中运行相同的程序,他是父进程的复制品
execve函数在当前进程的上下文中加载并运行一个程序,他会**覆盖当前进程的地址空间**,**没有创建新的进程**
新的程序仍然有相同得到PID,并继承了调用execve函数时已打开的文件描述符
新程序的代码和数据成为当前进程的代码和数据


如果执行一个helloworld程序:简答 期末题6分,一点一分,还可以再加入虚拟内存翻译的内容
- shell接收命令
- shell首先fork出一个子进程
- 子进程执行execve加载helloworld程序
- 执行程序中若发现有页面未在内存 执行缺页中断程序
- 如果发生了缺页中断,缺页中断处理程序负责把页面调入内存,同时可能会选择页面换出内存
- 程序执行时,执行printf函数的动态链接
- 程序结束后,由父进程负责回收子进程资源


### 信号

信号(singal)就是一个小消息,它允许进程和内核中断其他进程

#### 发送信号

- 内核检测到一个系统事件(如除0)
- 一个进程调用了kill函数,显式地要求内核发送信号给目的进程.(也可以发送给自己)

#### 接收信号

目的进程被内核强迫对信号的发送做出反应时,它就接受了信号

进程可以
- 忽略这个信号
- 终止
- 执行**信号处理程序**(signal handler)的用户层函数捕获它

一个发出但没有被接受的信号称**待处理信号**(pending signal)
任何时刻**一种信号**至多只会有一个待处理信号
对目的进程发送**重复类型的待处理信号**会被简单**丢弃**,不会排队等待
进程可以选择性的阻塞某类型的信号 被阻塞的信号仍可发送,但不会被接受

#### Ctrl+C

- 键下Ctrl+C的作用: 发送**SIGINT**给前台进程组的每个进程 默认行为是**终止**

#### 信号处理程序

- 处理程序要尽可能简单
- 只调用异步信号安全的函数
- 用volatile声明全局变量(编译器不会缓存)

### 非本地跳转

setjump **调用一次可多次返回**
C语言提供的用户级异常控制流
将控制直接从一个函数转移到另一个正在执行的函数,而不通过调用返回序列