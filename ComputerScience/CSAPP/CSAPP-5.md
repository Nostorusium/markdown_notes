# CSAPP章节小结

## 第五章 优化程序性能

- 理解妨碍优化的因素
- 掌握面向编译器的优化方法
- 理解现代处理器提供的指令集并行
- 掌握指令集并行的优化方法

简答+代码

- 编译器自动实现的-O1优化：
  代码移动、简化复杂运算、共享共用子表达式
- **面向编译器**：
  消除循环低效率，减少过程调用，消除不必要的内存引用
- 面向CPU：循环展开：
  Nx1 NxN Nx1a
- 面向cache：
  调整变量顺序 P448，分块矩阵

2020: 20分大题，课本例题
2021：选择题
2022：:10分大题，期末改编题

### 编译器优化能力

编译器必须很小心地对程序使用**安全的优化**

1. 指针别名/内存别名
   编译器必须假设不同名的指针可能指向同一位置，这限制了优化策略。

2. 函数调用
   函数的调用可能产生 *副作用*：改变全局程序状态
   编译器不会判断函数是否有副作用，只会假设最糟糕的情况。

### 编译器优化

**- O1可优化的，编译器自动优化的、一般有用的：**

1. 代码移动
   把产生相同结果的计算从循环中移出。
2. 运算简化
   如乘除法转换为移位

**- 面向编译器的优化：**

1. 消除循环的低效率
   把**函数调用移出循环**(如计算长度)
   编译器很可能无法识别函数的副作用而不做优化,这通常需要程序员人工完成

2. 减少过程调用
   考虑：包装好的结构，提供了get()方法，通过index来获取元素
   现在：直接访问数组,data[i]获取元素。
   这虽然**破坏了抽象性与模块性**，但减少了这个过程中的函数引用。

3. 消除不必要的**内存引用**
   考虑使用临时变量累积计数。
   如用sum累加后再访存，而不是每次都通过指针访问逐次累加。

总结一下就是尽量减少**函数调用**与**内存访问**

### 现代处理器优化

不同于y86-64 现代处理器有多个功能单元，可以实现**并行**

针对处理器的优化重点在削弱关键路径上的相关性。
相关性会造成流水线的迟滞。
理想情况是逼近最大吞吐量界限，最大限度的实现完全流水。

**1. 功能单元的性能**
   加减乘除各自的运算有着各自的运算单元.
   延迟：表示完成某运算的总时间
   发射时间：连续2个同类型的运算之间需要的最小周期数,即多久可以再执行一次同样的运算
   容量：执行该运算功能单元的数量 如*i7 Haswell*有4个单元可以执行整数操作
   **吞吐量**：1/发射时间 单位周期进行多少运算
   **最大吞吐量**：理想情况下，完全流水化，每周期发射1次

**2. 界限**
   功能单元的延迟,发射时间和容量都会影响函数的性能,我们提出了两种界限.
   **CPE**:Cycle Per Element 每元素周期 越小越快
   计算：多久/几次计算
   **延迟界限**：表示严格顺序完成运算所需要的最小CPE值,这是可以通过修改函数进行优化的.
   **吞吐量界限**：给出了CPE的最小界限。最理想情况，不会比该界限更小。
   优化的目的：消除延迟的制约，尽可能逼近吞吐量界限。

**3. 数据流**
   如循环寄存器，上次迭代的值会在下一次中用到，这产生了顺序相关。
   数据流在功能单元之间传递，迭代之间累积的数据传递有数据相关性。
   制约程序性能的，便是相关数据传递链路中的**关键路径**上的顺序相关。
   我们的目的是尽量减小这种相关，使关键路径上产生的相关性尽可能少。

**4. 循环展开**
   MxN展开：M为每个循环处理几个元素，循环的步长； N为路数，积累值的个数。

   关键路径：计算最多的那条，可以有多条

   目的是通过增加每次迭代计算元素的数量来减少循环的迭代次数，从而减少**关键路径**上的操作数量。
   **Nx1展开**：每次处理N个。N也可以理解为循环的步长。
   无法将性能改进到超过延迟界限。
   当迭代次数减少，每次迭代的计算量也增加。考虑N=2，次数减少为N/2，而由于相关性每次都要先后计算2次。
   2*N/2仍是N。**无法突破延迟界限**。

**5. 并行**
   要突破延迟界限，就要**打破顺序相关**。
   也就是使用多路并行，利用现代处理器的并行能力。
   考虑之前的2x1展开，每次迭代都要按顺序计算2次。
   现在拆成两路分开算，一路算奇数，一路算偶数。这两路之间没有顺序相关性。
   所以变成两条关键路径，每条都是N/2
   **NxN展开打破了延迟界限**
   将多个累计变量变换归纳为循环展开N次，并行积累N个值，只要N足够大就可以逼近吞吐量上限。

**6. 重新结合变化 Nx1a**
   另一种打破顺序相关的方法。
   通过重新结合运算，使发生相关的链路上运算尽可能少。
   **Nx1a**,a:(re)association

   ```C
   #循环展开2次
   acc = (acc * data[i]) * data[i+1]
   #重新结合 因为相关性来源于acc，所以最后算acc，尽量减少关键路径上的计算操作
   acc = acc * (data[i] * data[i+1])
   ```

**7. 习题**
5.5 5.6 P366
5.8 P376
期末题：采用一般有用的/面向编译器的/面向CPU优化/面向Cache的优化程序 任意一种或几种 写出程序和理由

步长为2的代码写法；两路的写法

### 面向Cache优化：第六章

```C
//期末题
int sum_array(int a[M][N][N]) //M N足够大
{
   int i,j,k,sum=0;
   for(i=0;i<N;i++)
      for(j=0;j<N;j++)
         for(k=0;k<M;k++)
            sum+=a[k][i][j];
   return sum;
}
```

```C
//面向Cache优化:调整变量顺序
看a[k][i][j],空间局部性体现在a[][][j]上
所以最内层循环要保证j的连续性才能最大限度利用空间局部性
把最内层循环改成j
至于a[k]和a[][i]，本来就不挨着。顺序随便
```

```C
//面向CPU优化-2x1展开
int sum_array(int a[M][N][N]) //M N足够大
{
   int i,j,k,sum=0;
   for(i=0;i<N;i++)
      for(j=0;j<N;j++)
      {   for(k=0;k<M;k+=2)
         {
            sum+=a[k][i][j]+a[k+1][i][j];
         }
         for(;k<M;k++)
         {   
            sum+=a[k][i][j];
         }
      }
   return sum;
}
```

```C
//面向CPU优化-2x2展开
int sum_array(int a[M][N][N]) //M N足够大
{
   int i,j,k,sum=0;
   int sum2=0;
   for(i=0;i<N;i++)
      for(j=0;j<N;j++)
         for(k=0;k<M;k+=2)
         {
            sum+=a[k][i][j];
            sum2+=a[k+1][i][j];
         }
         for(;k<M;k++)
         {
            sum+=a[k][i][j];
         }
   sum = sum+sum2;
   return sum;
}
```
