# Some perspectives from Computer Organization and Design

## 运算

### 为什么是补码?

计算机程序对正数和负数都要进行计算，所以需要一种方法来区分正数和负数。
最显而易见的方法就是加一个符号位，而一方面将符号位放在哪里存在争议，而且在带有符号位表示的数中会同时出现正零与负零。这会给程序员带来负担。于是加符号位方案很快被放弃了。  

在研究其他方案是产生了这样一个问题：当用一个很大的数去减一个很小的数，将造成前面的位都变成了一串1。在没有更好选择的情况下，最终解决方案采用了这样一个易于计算机实现的方式：前导位为0表示正数，前导位为1表示负数。即计算机补码，Two's Complement。  

要计算一个补码的相反数有一个窍门：  
一个数与它每一位取反之和为：1111...1111 即-1  
那么 $ x+ x_{取反} = -1$ , $ x+ x_{取反} + 1 = 0$  
于是 $ -x = x_{取反} + 1$  

### 为什么偏移寻址？

考虑一个MIPS条件分支指令：

```
|   ..   |  ..  |  ..  |    Exit    |
|  6bit  | 5bit | 5bit |    16bit   |   total:32
```

如果程序地址由该16位地址指定，这意味着任何程序都不能大于2^16  
另一个办法是用一个寄存器+该指定地址得到最终地址。即偏移寻址。  
对于分支预测而言，大概一半的条件分支的跳转范围都在PC值附近，因此通常采用程序计数器偏移。
于是我们得到了PC相对寻址，MIPS对所有条件分支都是用PC相对寻址，他们的跳转目标一般比较接近当前PC，即当前分支指令本身。

### 怎么乘法

```
      1000
    x 1001
----------------
      1000
     0000
    0000
   1000
----------------
   1001000
```

如果没有相关硬件支持，不妨将1000加1001次。  

在ALU，位移器，寄存器的硬件支持下，可将这个竖式乘法转化到硬件结构上：  
被乘数寄存器: 1000  
乘数寄存器: 1001  
乘积寄存器: 0 并逐次累加.  
每次取乘数的最低位与整个被乘数运算。如果是0，说明结果是0，直接进入下一轮。如果是1，则进行运算。  
由于结果需要累加到高位，所以此时将乘数左移一位，以便让它加到更高的位置。  

摩尔定律为我们提供了非常充足的资源，硬件设计者可以设计更快速的**乘法器**。比如：为乘数的每一位都配备加法器进行二分加速，甚至更快、易于流水线的方式。  

### 浮点数

浮点数，就是科学计数法。所谓的规格化浮点数，其实是规格化科学计数法。  

对于一个规格化的科学计数法表示的数，要求小数点前只有一位，且不为前导零。  
如 $1.0_{10}*10^{-9}$ 是规格化的，而 $0.1_{10}*10^{-8}$ 与 $10_{10}.0*10^{-10}$ 不是。

一个浮点数由符号位，指数Exponent和尾数Fraction构成。指数会增加数的表示范围，尾数将会增加表示精度。因此浮点数必须在两者之间取一个折中。  

**单精度： 1符号位  8指数位   23尾数位**  
**双精度： 1符号位  11指数位  52尾数位**  

于是一个浮点数表示为： $ (-1)^S*F*2^E $  

因为规格化一定是前导1的，所以 IEEE754 甚至隐藏了这一位1，来将更多数据位打包到有效位数。于是单精度的数宽其实有24位(+1),双精度由53位(+1)。
此时一个浮点数表示为： $ (-1)^S*(F+1)*2^E $  

IEEE754的设计者希望浮点能够比较处理排序比较，因此在浮点数结构中，先出现符号位，然后出现指数位与尾数位。
而现在仍有一些问题：当我们采用补码或者其他编码时，可能造成指数位的最高位是1，从而导致一个负的指数看起来很大，这又不利于比较了。比如：

```
S  |           E             |       F
31 | 30 29 28 27 26 25 24 23 | 22 21 20 ... 0
0  | 1  1  1  1  1  1  1  1  | 0  0  0  ... 0
```

该浮点数为 $1.0_2*2^{-1}$

```
S  |           E             |       F
31 | 30 29 28 27 26 25 24 23 | 22 21 20 ... 0
0  | 0  0  0  0  0  0  0  1  | 0  0  0  ... 0
```

该浮点数为 $1.0_2*2^{+1}$
在比较E时，看起来很大的数反而比一个看起来很小的数要小。  
因此我们更希望计数法能够把最小的负指数表示为000..000，最大的正指数表示为111...111的形式。于是放弃补码，引入一个偏移实现，该计数法称为带偏阶的计数 biased notation，或**移码**。用真实指数+偏移值后的值取代原指数部分。

IEEE754规定单精度偏阶为127(01111111)，双精度为1023。  
此时，浮点数表示为： $(-1)^S *(1+尾数)*2^{指数-偏阶} $  
原-1将表示为+126，原+1表示为+128.  

单精度表示范围为：
$ ±1.000...000 * 2^{-126} $ ~ $ ±1.111...111 * 2^{+127}$  
8位移码可表示(0 ~ 255)，而指数部分全0与全1都表示有特殊意义。  
于是指数部分的实际取值是(1 ~ 254)，对应真实指数(-126 ~ +127)  
偏移量取127，正好得到 (-126 ~ 0) 和 (1 ~ 127) 两个均匀分布。这也是为什么不用128作为偏移。

### 浮点规格化

将 $0.2*10^{-7}$ 规格化为 $2.0*10^{-6}$ 即向左规格化。  
该过程可能持续多次，每次都需要令尾数左移1位，让阶码-1  
  
将 $20.0*10^{-9}$ 规格化为 $2.0*10^{-8}$ 即向右规格化。  
当尾数发生了进位，则只需右规一次，令尾数右移1位，阶码+1  

### 标志位

- ZF zero flag 零
- OF overflow flag 有符号-溢出
- SF sign flag 有符号-最高位符号
- CF carry flag 进/借位

众所周知机器级分支判断可以使用标志位进行算术判断。  
无符号数A-B:  
- A=B ZF=1
- A>B ZF=0,CF=0
- A>=B CF=0
- A<B ZF=0,CF=1
- A<=B ZF=1 || CF=1

## 存储器

### RAM

重申一下其全称为Random Access Memory 与 Read-only Memory。  
内存主要采用DRAM，Dynamic RAM。  
靠近处理器的cache主要采用SRAM，Static RAM。  
区别于ROM，RAM都是易失的，不持续供电就会失去信息。  

DRAM使用电容保存电荷，所以不能长久地保存数据，必须周期刷新一下，于是得名动态。而SRAM不需要刷新，因此称静态。  

由于DRAM需要频繁刷新，因此采用了一个更高效的两级译码结构，在一个读周期后紧跟一个写周期一次刷新一整行，一行单元共用一个字线。  

> 16M*8的DRAM芯片，需要多少地址线和数据线？
> 16M = 2^24 = 2^12 * 2^12，即该DRAM有 2^12 行 2^12 列个块，每块存8bit，每次访存可访问一行/一列。
> 则访问到一块只需要2 * 2=4地址线，数据线8。

### ROM

ROM和RAM都采取随机存储的访问方式。读效率远高于写效率（如果可以）。  

- 闪速存储器Flash Memory由Intel在90年代发明，既又EEPROM的特点（断电不损失），又有RAM的特点（可擦写），相当于硬盘。主要用于U盘，存储卡等。
- 固态硬盘Solid State Drive则是基于闪速存储器制作出来的。
  
闪存和SSD都属于广义上的ROM，但又没有保留其只读的特性。
