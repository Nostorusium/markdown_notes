# HTTP协议

HTTP是用于获取例如HTML文档这类资源的协议，也是Web上进行任何数据交换的基础。同时也是一种C-S协议。
一个完整的网页文档通常有文本，布局描述，图片，视频，脚本等构成。

客户端和服务端之间通过交换一个个独立的消息而非数据流进行通信。由客户端发出的消息为请求request，于是服务端发出的应答叫做响应response。

## 组成

作为一个C-S协议，请求由一个实体即用户代理(user agent)或者一个可以代表它的代理方(proxy)发出。
大多数情况下，这个用户代理就是一个浏览器，但它也可以是任何东西，比如一个机器爬虫。

>用户代理 User-Agent是能够代表用户行为的工具，以浏览器为主。
>但它也可能是调试使用的程序。
>浏览器总是首先发起请求的实体。

在Web浏览器和服务器之间，很多设备都参与了HTTP消息的传递。传递过程中的多数操作位于传输层，网络层等下层，他们对于HTTP应用层而言是透明的。还有一部分实体在应用层参与消息传递，一般被称为**代理**(proxy)。代理可以使透明的，即只转发并不做任何修改。也可以表现得不透明，在传递给服务端之前做一些修改。代理可以有很多作用，比如缓存、过滤、负载均衡、认证、日志等。

## HTTP的基本性质

HTTP被设计得简单易读，尽管在HTTP/2中HTTP消息被封装进帧。在HTTP/1.0引入的HTTP标头让这个协议易于扩展。
只需要服务器和客户端之间对新的标头(header)的语义经过简单的协商，新的功能就可以被加入进来。

> HTTP header允许客户端和服务端通过request或response传递附加的信息
> 一个标头由名字,冒号: 和具体的值构成
> 比如 NAME: WTF

HTTP是无状态的，同一个连接中，两个成功执行的请求之间没有关系。所以用户不能在网站中进行连贯的交互。
但Cookie的帮助有利于维护有状态的绘画。利用标头的扩展性，HTTP Cookie也加入了协议的工作流程。

HTTP采用TCP连接，由传输层来控制，因此从根本上说TCP不属于HTTP的范畴。HTTP不需要底层的传输协议是面向连接的，仅仅需要它是可靠的，至少不会丢失信息。因此在最常用的传输协议中，HTTP使用TCP连接。

HTTP/1.0默认为每一**对**HTTP请求和响应都打开一个单独的TCP连接，当需要发起多个请求，效率就很低了。
为了减轻这个缺陷，HTTP/1.1引入了流水线和持久化链接，标头Connection可以控制底层的TCP连接。

## HTTP流

当客户端想要和服务器，不管是最终的服务器还是中间的代理进行信息交互，过程表现为以下几步：

1. 打开一个TCP连接(三次握手建立)
2. 发送一个HTTP报文
3. 读取服务端返回的报文信息
4. 关闭连接或者为后续请求重用连接

请求和响应为一对，或每次都新建连接，或者复用连接。
当启用HTTP流水线时，后续的request不需要等待response就可以直接发送，然而HTTP流水线已被证明很难在现有的网络中实现。因为现有网络中有老旧的软件和现代版本的软件同时存在。因此HTTP流水线在HTTP/2中被更加健壮的，使用帧的多路复用请求所取代。

## 报文结构

```
GET / HTTP/1.1
Host: abaaba.com
Accept-Language: zh
```

**HTTP请求报文**的第一行包括：方法 - 路径 - 协议版本
- HTTP方法通常是一个动词例如GET，POST，或者一个名词OPTIONS，HEAD来定义客户端执行的动作。
经典的场景有客户端想要获取某个资源：使用GET。发送HTML表单的参数值：使用POST。
- 路径表示要获取资源的那个路径，这里去除了当前上下文中的一些显而易见的信息。比如他不包括协议信息(http://)、不包括域名(abaaba.com)，不包括TCP端口号(80)。
- 协议版本就是HTTP的版本号。

第一行下面的都是可选的标头和请求体body。
可选的header通常存储一些额外信息。
而请求体body也类似响应中的body，一些像POST这样的方法会把需要发送的资源放在这里。

```
HTTP/1.1 200 OK
data: Tue, 18 Jn 2024 10:03:55 GMT
cache-control: public,max-age=3600
content-type: text/html
```

**HTTP请求报文**的第一行包括：协议版本- 状态码 - 状态信息
标头部分与请求标头类似。
可选项则包含被获取资源的主体。

## 一次请求过程

1. 输入网址
2. 浏览器进行DNS解析
3. 根据IP地址，找到服务器，三次握手建立TCP连接
4. 连接建立后，发起HTTP请求报文
5. 服务器响应请求，发送HTTP响应报文
6. 浏览器获得响应并解析，渲染器把页面呈现给用户
7. 服务器四次握手关闭TCP连接。