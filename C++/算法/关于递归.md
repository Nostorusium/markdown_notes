# 递归

1. 递归的基础情况
   指在数据规模足够小时直接返回答案。
2. 递归调用
   我们把递归调用认为是一种超级操作。此处的递归调用是为了解决子问题。
   此处没有具体的处理。
3. 递归到当前层
   称之为微操作，用于当前层的具体处理。

不要质疑第二步的超级操作的可行。当你对第二步这一超级操作产生怀疑，你就会试图探寻这个操作下一步的执行情况，进而被复杂的层叠关系搞晕。
要默认使用递归调用时它能够履行他的使命，忽略超级操作里面的一切细节，把它视为一个整体，假定它一定能完成任务。

递归的关键在于递推到当前层的微操作。类比数学归纳法，只要处理好基础归纳和微操作的具体处理逻辑，就一定成立。

以汉诺塔举例，挪动10个圆盘，我们可以拆解为3个子步骤：

1. 超级操作，挪动9个圆盘到B
2. 微操作，真正需要处理的操作 把最下面的圆盘挪到C
3. 超级操作，把B的九个圆盘挪到C

其中超级操作1，3被视为是一个整体，我们坚定地认为它能够履行挪动九个圆盘的使命。

```
/*
基础处理：递归基本收敛条件
超级操作：得到以i开始的递增子序列最长长度
微操作：每层中的具体处理

1. 收敛处理 return
2. 超级操作：得到后续位置递增子序列最大长度
3. 微操作： 进行比较取最大值

*/

// 时间复杂度指数级 O(2^n) 优化见动态规划
int recursionSolution(const std::vector<int>& nums,int index){
    if(index == nums.size()-1){
        return 1;
    }

    int maxlength = 1;
    for(int i=index+1;i<nums.size();i++){
        if(nums[i] > nums[index]){
            maxlength = max(recursionSolution(nums,i)+1,maxlength);
        }
    }
    return maxlength;
}

```